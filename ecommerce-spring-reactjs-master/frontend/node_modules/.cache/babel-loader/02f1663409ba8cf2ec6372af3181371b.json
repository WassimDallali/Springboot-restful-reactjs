{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedDirectives } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  var _loop = function _loop(_i4) {\n    var stdDirective = specifiedDirectives[_i4];\n\n    if (directives.every(function (directive) {\n      return directive.name !== stdDirective.name;\n    })) {\n      directives.push(stdDirective);\n    }\n  };\n\n  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/utilities/buildASTSchema.mjs"],"names":["devAssert","Kind","parse","assertValidSDL","GraphQLSchema","specifiedDirectives","extendSchemaImpl","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","emptySchemaConfig","description","undefined","types","directives","extensions","extensionASTNodes","config","astNode","_i2","_config$types2","length","type","name","query","mutation","subscription","_loop","_i4","stdDirective","every","directive","push","buildSchema","source","document","noLocation","allowLegacySDLEmptyFields","allowLegacySDLImplementsInterfaces","experimentalFragmentVariables","commentDescriptions"],"mappings":"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","sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedDirectives } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  var _loop = function _loop(_i4) {\n    var stdDirective = specifiedDirectives[_i4];\n\n    if (directives.every(function (directive) {\n      return directive.name !== stdDirective.name;\n    })) {\n      directives.push(stdDirective);\n    }\n  };\n\n  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"]},"metadata":{},"sourceType":"module"}