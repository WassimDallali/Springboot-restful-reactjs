{"ast":null,"code":"import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"names":["arrayFrom","didYouMean","suggestionList","naturalCompare","GraphQLError","isObjectType","isInterfaceType","isAbstractType","FieldsOnCorrectTypeRule","context","Field","node","type","getParentType","fieldDef","getFieldDef","schema","getSchema","fieldName","name","value","suggestion","getSuggestedTypeNames","getSuggestedFieldNames","reportError","concat","suggestedTypes","Set","usageCount","Object","create","_i2","_schema$getPossibleTy2","getPossibleTypes","length","possibleType","getFields","add","_i4","_possibleType$getInte2","getInterfaces","_usageCount$possibleI","possibleInterface","sort","typeA","typeB","usageCountDiff","isSubType","map","x","possibleFieldNames","keys"],"mappings":"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","sourcesContent":["import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"module"}