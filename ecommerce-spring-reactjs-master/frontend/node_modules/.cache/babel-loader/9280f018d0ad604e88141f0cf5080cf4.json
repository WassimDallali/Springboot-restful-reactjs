{"ast":null,"code":"function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport objectEntries from \"../polyfills/objectEntries.mjs\";\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport toObjMap from \"../jsutils/toObjMap.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\nimport didYouMean from \"../jsutils/didYouMean.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport identityFunc from \"../jsutils/identityFunc.mjs\";\nimport defineInspect from \"../jsutils/defineInspect.mjs\";\nimport suggestionList from \"../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { valueFromASTUntyped } from \"../utilities/valueFromASTUntyped.mjs\";\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL type.\"));\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL List type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL input type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL output type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\"));\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(PersonType) },\n *         children: { type: new GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n// FIXME: workaround to fix issue with Babel parser\n\n/* ::\ndeclare class GraphQLList<+T: GraphQLType> {\n  +ofType: T;\n  static <T>(ofType: T): GraphQLList<T>;\n  // Note: constructors cannot be used for covariant types. Drop the \"new\".\n  constructor(ofType: GraphQLType): void;\n}\n*/\n\nexport function GraphQLList(ofType) {\n  // istanbul ignore else (to be removed in v16.0.0)\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n};\n\nGraphQLList.prototype.toJSON = function toJSON() {\n  return this.toString();\n};\n\nObject.defineProperty(GraphQLList.prototype, SYMBOL_TO_STRING_TAG, {\n  get: function get() {\n    return 'GraphQLList';\n  }\n}); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: new GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n// FIXME: workaround to fix issue with Babel parser\n\n/* ::\ndeclare class GraphQLNonNull<+T: GraphQLNullableType> {\n  +ofType: T;\n  static <T>(ofType: T): GraphQLNonNull<T>;\n  // Note: constructors cannot be used for covariant types. Drop the \"new\".\n  constructor(ofType: GraphQLType): void;\n}\n*/\n\nexport function GraphQLNonNull(ofType) {\n  // istanbul ignore else (to be removed in v16.0.0)\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n};\n\nGraphQLNonNull.prototype.toJSON = function toJSON() {\n  return this.toString();\n};\n\nObject.defineProperty(GraphQLNonNull.prototype, SYMBOL_TO_STRING_TAG, {\n  get: function get() {\n    return 'GraphQLNonNull';\n  }\n}); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\"));\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL named type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  // $FlowFixMe[incompatible-use]\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction undefineIfEmpty(arr) {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType = /*#__PURE__*/function () {\n  function GraphQLScalarType(config) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral;\n\n    var parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;\n    this.name = config.name;\n    this.description = config.description;\n    this.specifiedByUrl = config.specifiedByUrl;\n    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : function (node, variables) {\n      return parseValue(valueFromASTUntyped(node, variables));\n    };\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.specifiedByUrl == null || typeof config.specifiedByUrl === 'string' || devAssert(0, \"\".concat(this.name, \" must provide \\\"specifiedByUrl\\\" as a string, \") + \"but got: \".concat(inspect(config.specifiedByUrl), \".\"));\n    config.serialize == null || typeof config.serialize === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar is also used as an input type, ensure \\\"parseValue\\\" and \\\"parseLiteral\\\" functions are also provided.\"));\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" functions.\"));\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toConfig = function toConfig() {\n    var _this$extensionASTNod;\n\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByUrl: this.specifiedByUrl,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : []\n    };\n  };\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLScalarType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLScalarType';\n    }\n  }]);\n\n  return GraphQLScalarType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLScalarType);\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\n\nexport var GraphQLObjectType = /*#__PURE__*/function () {\n  function GraphQLObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\"));\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  _proto2.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLObjectType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLObjectType';\n    }\n  }]);\n\n  return GraphQLObjectType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var _resolveThunk;\n\n  var interfaces = (_resolveThunk = resolveThunk(config.interfaces)) !== null && _resolveThunk !== void 0 ? _resolveThunk : [];\n  Array.isArray(interfaces) || devAssert(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns an Array.\"));\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object.\"));\n    !('isDeprecated' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(fieldConfig.resolve), \".\"));\n    var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument names as keys.\"));\n    var args = objectEntries(argsConfig).map(function (_ref) {\n      var argName = _ref[0],\n          argConfig = _ref[1];\n      return {\n        name: argName,\n        description: argConfig.description,\n        type: argConfig.type,\n        defaultValue: argConfig.defaultValue,\n        deprecationReason: argConfig.deprecationReason,\n        extensions: argConfig.extensions && toObjMap(argConfig.extensions),\n        astNode: argConfig.astNode\n      };\n    });\n    return {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: args,\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      isDeprecated: fieldConfig.deprecationReason != null,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, function (field) {\n    return {\n      description: field.description,\n      type: field.type,\n      args: argsToArgsConfig(field.args),\n      resolve: field.resolve,\n      subscribe: field.subscribe,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    };\n  });\n}\n/**\n * @internal\n */\n\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(args, function (arg) {\n    return arg.name;\n  }, function (arg) {\n    return {\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode\n    };\n  });\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\n\nexport var GraphQLInterfaceType = /*#__PURE__*/function () {\n  function GraphQLInterfaceType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto3.toConfig = function toConfig() {\n    var _this$extensionASTNod2;\n\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== void 0 ? _this$extensionASTNod2 : []\n    };\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  _proto3.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLInterfaceType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLInterfaceType';\n    }\n  }]);\n\n  return GraphQLInterfaceType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLInterfaceType);\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\n\nexport var GraphQLUnionType = /*#__PURE__*/function () {\n  function GraphQLUnionType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._types = defineTypes.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toConfig = function toConfig() {\n    var _this$extensionASTNod3;\n\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== void 0 ? _this$extensionASTNod3 : []\n    };\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  _proto4.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLUnionType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLUnionType';\n    }\n  }]);\n\n  return GraphQLUnionType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types);\n  Array.isArray(types) || devAssert(0, \"Must provide Array of types or a function which returns such an array for Union \".concat(config.name, \".\"));\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nexport var GraphQLEnumType\n/* <T> */\n=\n/*#__PURE__*/\nfunction () {\n  function GraphQLEnumType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(outputValue) {\n    var enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new GraphQLError(\"Enum \\\"\".concat(this.name, \"\\\" cannot represent value: \").concat(inspect(outputValue)));\n    }\n\n    return enumValue.name;\n  };\n\n  _proto5.parseValue = function parseValue(inputValue)\n  /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      var valueStr = inspect(inputValue);\n      throw new GraphQLError(\"Enum \\\"\".concat(this.name, \"\\\" cannot represent non-string value: \").concat(valueStr, \".\") + didYouMeanEnumValue(this, valueStr));\n    }\n\n    var enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new GraphQLError(\"Value \\\"\".concat(inputValue, \"\\\" does not exist in \\\"\").concat(this.name, \"\\\" enum.\") + didYouMeanEnumValue(this, inputValue));\n    }\n\n    return enumValue.value;\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== Kind.ENUM) {\n      var valueStr = print(valueNode);\n      throw new GraphQLError(\"Enum \\\"\".concat(this.name, \"\\\" cannot represent non-enum value: \").concat(valueStr, \".\") + didYouMeanEnumValue(this, valueStr), valueNode);\n    }\n\n    var enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      var _valueStr = print(valueNode);\n\n      throw new GraphQLError(\"Value \\\"\".concat(_valueStr, \"\\\" does not exist in \\\"\").concat(this.name, \"\\\" enum.\") + didYouMeanEnumValue(this, _valueStr), valueNode);\n    }\n\n    return enumValue.value;\n  };\n\n  _proto5.toConfig = function toConfig() {\n    var _this$extensionASTNod4;\n\n    var values = keyValMap(this.getValues(), function (value) {\n      return value.name;\n    }, function (value) {\n      return {\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      values: values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== void 0 ? _this$extensionASTNod4 : []\n    };\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  _proto5.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLEnumType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLEnumType';\n    }\n  }]);\n\n  return GraphQLEnumType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLEnumType);\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  var allNames = enumType.getValues().map(function (value) {\n    return value.name;\n  });\n  var suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(0, \"\".concat(typeName, \" values must be an object with value names as keys.\"));\n  return objectEntries(valueMap).map(function (_ref2) {\n    var valueName = _ref2[0],\n        valueConfig = _ref2[1];\n    isPlainObj(valueConfig) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(valueConfig), \".\"));\n    !('isDeprecated' in valueConfig) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    return {\n      name: valueName,\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      isDeprecated: valueConfig.deprecationReason != null,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: valueConfig.extensions && toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLInputObjectType = /*#__PURE__*/function () {\n  function GraphQLInputObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toConfig = function toConfig() {\n    var _this$extensionASTNod5;\n\n    var fields = mapValue(this.getFields(), function (field) {\n      return {\n        description: field.description,\n        type: field.type,\n        defaultValue: field.defaultValue,\n        extensions: field.extensions,\n        astNode: field.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== void 0 ? _this$extensionASTNod5 : []\n    };\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  _proto6.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLInputObjectType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLInputObjectType';\n    }\n  }]);\n\n  return GraphQLInputObjectType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    !('resolve' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but Input Types cannot define resolvers.\"));\n    return {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/type/definition.mjs"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","objectEntries","SYMBOL_TO_STRING_TAG","inspect","keyMap","mapValue","toObjMap","devAssert","keyValMap","instanceOf","didYouMean","isObjectLike","identityFunc","defineInspect","suggestionList","GraphQLError","Kind","print","valueFromASTUntyped","isType","type","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isListType","isNonNullType","assertType","Error","concat","GraphQLScalarType","assertScalarType","GraphQLObjectType","assertObjectType","GraphQLInterfaceType","assertInterfaceType","GraphQLUnionType","assertUnionType","GraphQLEnumType","assertEnumType","GraphQLInputObjectType","assertInputObjectType","GraphQLList","assertListType","GraphQLNonNull","assertNonNullType","isInputType","isWrappingType","ofType","assertInputType","isOutputType","assertOutputType","isLeafType","assertLeafType","isCompositeType","assertCompositeType","isAbstractType","assertAbstractType","toString","String","toJSON","get","assertNullableType","assertWrappingType","isNullableType","getNullableType","isNamedType","assertNamedType","getNamedType","unwrappedType","resolveThunk","thunk","undefineIfEmpty","arr","undefined","config","_config$parseValue","_config$serialize","_config$parseLiteral","parseValue","name","description","specifiedByUrl","serialize","parseLiteral","node","variables","extensions","astNode","extensionASTNodes","_proto","toConfig","_this$extensionASTNod","isTypeOf","_fields","defineFieldMap","bind","_interfaces","defineInterfaces","_proto2","getFields","getInterfaces","interfaces","fields","fieldsToFieldsConfig","_resolveThunk","Array","isArray","fieldMap","isPlainObj","fieldConfig","fieldName","_fieldConfig$args","resolve","argsConfig","args","map","_ref","argName","argConfig","defaultValue","deprecationReason","subscribe","isDeprecated","obj","field","argsToArgsConfig","arg","isRequiredArgument","resolveType","_proto3","_this$extensionASTNod2","_types","defineTypes","_proto4","getTypes","_this$extensionASTNod3","types","_values","defineEnumValues","values","_valueLookup","Map","enumValue","value","_nameLookup","_proto5","getValues","getValue","outputValue","inputValue","valueStr","didYouMeanEnumValue","valueNode","_variables","kind","ENUM","_valueStr","_this$extensionASTNod4","enumType","unknownValueStr","allNames","suggestedValues","typeName","valueMap","_ref2","valueName","valueConfig","defineInputFieldMap","_proto6","_this$extensionASTNod5","isRequiredInputField"],"mappings":"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","sourcesContent":["function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport objectEntries from \"../polyfills/objectEntries.mjs\";\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport toObjMap from \"../jsutils/toObjMap.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\nimport didYouMean from \"../jsutils/didYouMean.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport identityFunc from \"../jsutils/identityFunc.mjs\";\nimport defineInspect from \"../jsutils/defineInspect.mjs\";\nimport suggestionList from \"../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { valueFromASTUntyped } from \"../utilities/valueFromASTUntyped.mjs\";\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL type.\"));\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL List type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL input type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL output type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\"));\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(PersonType) },\n *         children: { type: new GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n// FIXME: workaround to fix issue with Babel parser\n\n/* ::\ndeclare class GraphQLList<+T: GraphQLType> {\n  +ofType: T;\n  static <T>(ofType: T): GraphQLList<T>;\n  // Note: constructors cannot be used for covariant types. Drop the \"new\".\n  constructor(ofType: GraphQLType): void;\n}\n*/\n\nexport function GraphQLList(ofType) {\n  // istanbul ignore else (to be removed in v16.0.0)\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n};\n\nGraphQLList.prototype.toJSON = function toJSON() {\n  return this.toString();\n};\n\nObject.defineProperty(GraphQLList.prototype, SYMBOL_TO_STRING_TAG, {\n  get: function get() {\n    return 'GraphQLList';\n  }\n}); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: new GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n// FIXME: workaround to fix issue with Babel parser\n\n/* ::\ndeclare class GraphQLNonNull<+T: GraphQLNullableType> {\n  +ofType: T;\n  static <T>(ofType: T): GraphQLNonNull<T>;\n  // Note: constructors cannot be used for covariant types. Drop the \"new\".\n  constructor(ofType: GraphQLType): void;\n}\n*/\n\nexport function GraphQLNonNull(ofType) {\n  // istanbul ignore else (to be removed in v16.0.0)\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n};\n\nGraphQLNonNull.prototype.toJSON = function toJSON() {\n  return this.toString();\n};\n\nObject.defineProperty(GraphQLNonNull.prototype, SYMBOL_TO_STRING_TAG, {\n  get: function get() {\n    return 'GraphQLNonNull';\n  }\n}); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\"));\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL named type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  // $FlowFixMe[incompatible-use]\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction undefineIfEmpty(arr) {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType = /*#__PURE__*/function () {\n  function GraphQLScalarType(config) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral;\n\n    var parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;\n    this.name = config.name;\n    this.description = config.description;\n    this.specifiedByUrl = config.specifiedByUrl;\n    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : function (node, variables) {\n      return parseValue(valueFromASTUntyped(node, variables));\n    };\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.specifiedByUrl == null || typeof config.specifiedByUrl === 'string' || devAssert(0, \"\".concat(this.name, \" must provide \\\"specifiedByUrl\\\" as a string, \") + \"but got: \".concat(inspect(config.specifiedByUrl), \".\"));\n    config.serialize == null || typeof config.serialize === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar is also used as an input type, ensure \\\"parseValue\\\" and \\\"parseLiteral\\\" functions are also provided.\"));\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" functions.\"));\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toConfig = function toConfig() {\n    var _this$extensionASTNod;\n\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByUrl: this.specifiedByUrl,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : []\n    };\n  };\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLScalarType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLScalarType';\n    }\n  }]);\n\n  return GraphQLScalarType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLScalarType);\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport var GraphQLObjectType = /*#__PURE__*/function () {\n  function GraphQLObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\"));\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  _proto2.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLObjectType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLObjectType';\n    }\n  }]);\n\n  return GraphQLObjectType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var _resolveThunk;\n\n  var interfaces = (_resolveThunk = resolveThunk(config.interfaces)) !== null && _resolveThunk !== void 0 ? _resolveThunk : [];\n  Array.isArray(interfaces) || devAssert(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns an Array.\"));\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object.\"));\n    !('isDeprecated' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(fieldConfig.resolve), \".\"));\n    var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument names as keys.\"));\n    var args = objectEntries(argsConfig).map(function (_ref) {\n      var argName = _ref[0],\n          argConfig = _ref[1];\n      return {\n        name: argName,\n        description: argConfig.description,\n        type: argConfig.type,\n        defaultValue: argConfig.defaultValue,\n        deprecationReason: argConfig.deprecationReason,\n        extensions: argConfig.extensions && toObjMap(argConfig.extensions),\n        astNode: argConfig.astNode\n      };\n    });\n    return {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: args,\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      isDeprecated: fieldConfig.deprecationReason != null,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, function (field) {\n    return {\n      description: field.description,\n      type: field.type,\n      args: argsToArgsConfig(field.args),\n      resolve: field.resolve,\n      subscribe: field.subscribe,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    };\n  });\n}\n/**\n * @internal\n */\n\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(args, function (arg) {\n    return arg.name;\n  }, function (arg) {\n    return {\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode\n    };\n  });\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport var GraphQLInterfaceType = /*#__PURE__*/function () {\n  function GraphQLInterfaceType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto3.toConfig = function toConfig() {\n    var _this$extensionASTNod2;\n\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== void 0 ? _this$extensionASTNod2 : []\n    };\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  _proto3.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLInterfaceType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLInterfaceType';\n    }\n  }]);\n\n  return GraphQLInterfaceType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLInterfaceType);\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport var GraphQLUnionType = /*#__PURE__*/function () {\n  function GraphQLUnionType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._types = defineTypes.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toConfig = function toConfig() {\n    var _this$extensionASTNod3;\n\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== void 0 ? _this$extensionASTNod3 : []\n    };\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  _proto4.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLUnionType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLUnionType';\n    }\n  }]);\n\n  return GraphQLUnionType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types);\n  Array.isArray(types) || devAssert(0, \"Must provide Array of types or a function which returns such an array for Union \".concat(config.name, \".\"));\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport var GraphQLEnumType\n/* <T> */\n= /*#__PURE__*/function () {\n  function GraphQLEnumType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(outputValue) {\n    var enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new GraphQLError(\"Enum \\\"\".concat(this.name, \"\\\" cannot represent value: \").concat(inspect(outputValue)));\n    }\n\n    return enumValue.name;\n  };\n\n  _proto5.parseValue = function parseValue(inputValue)\n  /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      var valueStr = inspect(inputValue);\n      throw new GraphQLError(\"Enum \\\"\".concat(this.name, \"\\\" cannot represent non-string value: \").concat(valueStr, \".\") + didYouMeanEnumValue(this, valueStr));\n    }\n\n    var enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new GraphQLError(\"Value \\\"\".concat(inputValue, \"\\\" does not exist in \\\"\").concat(this.name, \"\\\" enum.\") + didYouMeanEnumValue(this, inputValue));\n    }\n\n    return enumValue.value;\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== Kind.ENUM) {\n      var valueStr = print(valueNode);\n      throw new GraphQLError(\"Enum \\\"\".concat(this.name, \"\\\" cannot represent non-enum value: \").concat(valueStr, \".\") + didYouMeanEnumValue(this, valueStr), valueNode);\n    }\n\n    var enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      var _valueStr = print(valueNode);\n\n      throw new GraphQLError(\"Value \\\"\".concat(_valueStr, \"\\\" does not exist in \\\"\").concat(this.name, \"\\\" enum.\") + didYouMeanEnumValue(this, _valueStr), valueNode);\n    }\n\n    return enumValue.value;\n  };\n\n  _proto5.toConfig = function toConfig() {\n    var _this$extensionASTNod4;\n\n    var values = keyValMap(this.getValues(), function (value) {\n      return value.name;\n    }, function (value) {\n      return {\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      values: values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== void 0 ? _this$extensionASTNod4 : []\n    };\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  _proto5.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLEnumType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLEnumType';\n    }\n  }]);\n\n  return GraphQLEnumType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLEnumType);\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  var allNames = enumType.getValues().map(function (value) {\n    return value.name;\n  });\n  var suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(0, \"\".concat(typeName, \" values must be an object with value names as keys.\"));\n  return objectEntries(valueMap).map(function (_ref2) {\n    var valueName = _ref2[0],\n        valueConfig = _ref2[1];\n    isPlainObj(valueConfig) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(valueConfig), \".\"));\n    !('isDeprecated' in valueConfig) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    return {\n      name: valueName,\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      isDeprecated: valueConfig.deprecationReason != null,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: valueConfig.extensions && toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport var GraphQLInputObjectType = /*#__PURE__*/function () {\n  function GraphQLInputObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toConfig = function toConfig() {\n    var _this$extensionASTNod5;\n\n    var fields = mapValue(this.getFields(), function (field) {\n      return {\n        description: field.description,\n        type: field.type,\n        defaultValue: field.defaultValue,\n        extensions: field.extensions,\n        astNode: field.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== void 0 ? _this$extensionASTNod5 : []\n    };\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  _proto6.toJSON = function toJSON() {\n    return this.toString();\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLInputObjectType, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLInputObjectType';\n    }\n  }]);\n\n  return GraphQLInputObjectType;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    !('resolve' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but Input Types cannot define resolvers.\"));\n    return {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n"]},"metadata":{},"sourceType":"module"}