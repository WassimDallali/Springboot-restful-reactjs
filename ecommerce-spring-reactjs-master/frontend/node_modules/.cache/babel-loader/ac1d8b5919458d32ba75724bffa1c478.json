{"ast":null,"code":"import { NetworkStatus } from \"./networkStatus.js\";\nimport { compact } from \"../utilities/index.js\";\nimport { invariant } from 'ts-invariant';\n\nvar Reobserver = function () {\n  function Reobserver(observer, options, fetch, shouldFetch) {\n    this.observer = observer;\n    this.options = options;\n    this.fetch = fetch;\n    this.shouldFetch = shouldFetch;\n  }\n\n  Reobserver.prototype.reobserve = function (newOptions, newNetworkStatus) {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      this.updatePolling();\n    }\n\n    var concast = this.fetch(this.options, newNetworkStatus);\n\n    if (this.concast) {\n      this.concast.removeObserver(this.observer, true);\n    }\n\n    concast.addObserver(this.observer);\n    return (this.concast = concast).promise;\n  };\n\n  Reobserver.prototype.updateOptions = function (newOptions) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  };\n\n  Reobserver.prototype.stop = function () {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  };\n\n  Reobserver.prototype.updatePolling = function () {\n    var _this = this;\n\n    var _a = this,\n        pollingInfo = _a.pollingInfo,\n        pollInterval = _a.options.pollInterval;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n\n      return;\n    }\n\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(pollInterval, 20) : invariant(pollInterval, 'Attempted to start a polling query without a polling interval.');\n\n    if (this.shouldFetch === false) {\n      return;\n    }\n\n    var info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n\n    var maybeFetch = function () {\n      if (_this.pollingInfo) {\n        if (_this.shouldFetch && _this.shouldFetch()) {\n          _this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: _this.options.fetchPolicy || \"cache-first\"\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n\n      ;\n    };\n\n    var poll = function () {\n      var info = _this.pollingInfo;\n\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  };\n\n  return Reobserver;\n}();\n\nexport { Reobserver };","map":{"version":3,"sources":["../../src/core/Reobserver.ts"],"names":[],"mappings":"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","sourcesContent":["import { WatchQueryOptions } from './watchQueryOptions';\nimport { NetworkStatus } from './networkStatus';\nimport { ApolloQueryResult } from './types';\nimport { Observer, Concast, compact } from '../utilities';\nimport { invariant } from 'ts-invariant';\n\n// Given that QueryManager#fetchQueryObservable returns only a single\n// query's worth of results, other code must be responsible for repeatedly\n// calling fetchQueryObservable, while ensuring that the ObservableQuery\n// consuming those results remains subscribed to the concatenation of all\n// the observables returned by fetchQueryObservable. That responsibility\n// falls to this Reobserver class. As a bonus, the Reobserver class is\n// perfectly poised to handle polling logic, since polling is essentially\n// repeated reobservation. In principle, this code could have remained in\n// the ObservableQuery class, but I felt it would be easier to explain and\n// understand reobservation if it was confined to a separate class.\nexport class Reobserver<TData, TVars> {\n  constructor(\n    private observer: Observer<ApolloQueryResult<TData>>,\n    private options: WatchQueryOptions<TVars, TData>,\n    // Almost certainly just a wrapper function around\n    // QueryManager#fetchQueryObservable, but this small dose of\n    // indirection means the Reobserver doesn't have to know/assume\n    // anything about the QueryManager class.\n    private fetch: (\n      options: WatchQueryOptions<TVars, TData>,\n      newNetworkStatus?: NetworkStatus,\n    ) => Concast<ApolloQueryResult<TData>>,\n    // If we're polling, there may be times when we should avoid fetching,\n    // such as when the query is already in flight, or polling has been\n    // completely disabled for server-side rendering. Passing false for\n    // this parameter disables polling completely, and passing a boolean\n    // function allows determining fetch safety dynamically.\n    private shouldFetch: false | (() => boolean),\n  ) {}\n\n  private concast?: Concast<ApolloQueryResult<TData>>;\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVars, TData>>,\n    newNetworkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      // When we call this.updateOptions(newOptions) in the branch above,\n      // it takes care of calling this.updatePolling(). In this branch, we\n      // still need to update polling, even if there were no newOptions.\n      this.updatePolling();\n    }\n\n    const concast = this.fetch(this.options, newNetworkStatus);\n\n    if (this.concast) {\n      // We use the {add,remove}Observer methods directly to avoid\n      // wrapping observer with an unnecessary SubscriptionObserver\n      // object, in part so that we can remove it here without triggering\n      // any unsubscriptions, because we just want to ignore the old\n      // observable, not prematurely shut it down, since other consumers\n      // may be awaiting this.concast.promise.\n      this.concast.removeObserver(this.observer, true);\n    }\n\n    concast.addObserver(this.observer);\n\n    return (this.concast = concast).promise;\n  }\n\n  public updateOptions(newOptions: Partial<WatchQueryOptions<TVars, TData>>) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  }\n\n  public stop() {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  }\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    const {\n      pollingInfo,\n      options: {\n        pollInterval,\n      },\n    } = this;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo &&\n        pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Go no further if polling is disabled.\n    if (this.shouldFetch === false) {\n      return;\n    }\n\n    const info = pollingInfo || (\n      this.pollingInfo = {} as Reobserver<TData, TVars>[\"pollingInfo\"]\n    )!;\n\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (this.shouldFetch && this.shouldFetch()) {\n          this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: this.options.fetchPolicy || \"cache-first\",\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      };\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}