{"ast":null,"code":"function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport find from \"../polyfills/find.mjs\";\nimport arrayFrom from \"../polyfills/arrayFrom.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport toObjMap from \"../jsutils/toObjMap.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { __Schema } from \"./introspection.mjs\";\nimport { GraphQLDirective, isDirective, specifiedDirectives } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from \"./definition.mjs\";\n/**\n * Test if the given value is a GraphQL schema.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _config$directives; // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n    !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    var allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n        var type = _config$types2[_i2]; // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {\n      var directive = _this$_directives2[_i4]; // Directives are not validated until validateSchema() is called.\n\n      if (isDirective(directive)) {\n        for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n          var arg = _directive$args2[_i6];\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (var _i8 = 0, _arrayFrom2 = arrayFrom(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {\n      var namedType = _arrayFrom2[_i8];\n\n      if (namedType == null) {\n        continue;\n      }\n\n      var typeName = namedType.name;\n      typeName || devAssert(0, 'One of the provided types for building the Schema is missing a name.');\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(typeName, \"\\\".\"));\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {\n          var iface = _namedType$getInterfa2[_i10];\n\n          if (isInterfaceType(iface)) {\n            var implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {\n          var _iface = _namedType$getInterfa4[_i12];\n\n          if (isInterfaceType(_iface)) {\n            var _implementations = this._implementationsMap[_iface.name];\n\n            if (_implementations === undefined) {\n              _implementations = this._implementationsMap[_iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            _implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  };\n\n  _proto.getImplementations = function getImplementations(interfaceType) {\n    var implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  } // @deprecated: use isSubType instead - will be removed in v16.\n  ;\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    return this.isSubType(abstractType, possibleType);\n  };\n\n  _proto.isSubType = function isSubType(abstractType, maybeSubType) {\n    var map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {\n          var type = _abstractType$getType2[_i14];\n          map[type.name] = true;\n        }\n      } else {\n        var implementations = this.getImplementations(abstractType);\n\n        for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {\n          var _type = _implementations$obje2[_i16];\n          map[_type.name] = true;\n        }\n\n        for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {\n          var _type2 = _implementations$inte2[_i18];\n          map[_type2.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  _proto.toConfig = function toConfig() {\n    var _this$extensionASTNod;\n\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],\n      assumeValid: this.__validationErrors !== undefined\n    };\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLSchema, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLSchema';\n    }\n  }]);\n\n  return GraphQLSchema;\n}();\n\nfunction collectReferencedTypes(type, typeSet) {\n  var namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {\n        var memberType = _namedType$getTypes2[_i20];\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {\n        var interfaceType = _namedType$getInterfa6[_i22];\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (var _i24 = 0, _objectValues2 = objectValues(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {\n        var field = _objectValues2[_i24];\n        collectReferencedTypes(field.type, typeSet);\n\n        for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {\n          var arg = _field$args2[_i26];\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (var _i28 = 0, _objectValues4 = objectValues(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {\n        var _field = _objectValues4[_i28];\n        collectReferencedTypes(_field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/type/schema.mjs"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","find","arrayFrom","objectValues","SYMBOL_TO_STRING_TAG","inspect","toObjMap","devAssert","instanceOf","isObjectLike","__Schema","GraphQLDirective","isDirective","specifiedDirectives","isObjectType","isInterfaceType","isUnionType","isInputObjectType","getNamedType","isSchema","schema","GraphQLSchema","assertSchema","Error","concat","config","_config$directives","__validationErrors","assumeValid","undefined","types","Array","isArray","directives","description","extensions","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","allReferencedTypes","Set","_i2","_config$types2","type","delete","collectReferencedTypes","_i4","_this$_directives2","directive","_i6","_directive$args2","args","arg","_typeMap","create","_subTypeMap","_implementationsMap","_i8","_arrayFrom2","namedType","typeName","name","_i10","_namedType$getInterfa2","getInterfaces","iface","implementations","objects","interfaces","push","_i12","_namedType$getInterfa4","_iface","_implementations","_proto","getQueryType","getMutationType","getSubscriptionType","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","getImplementations","interfaceType","isPossibleType","possibleType","isSubType","maybeSubType","map","_i14","_abstractType$getType2","_i16","_implementations$obje2","_type","_i18","_implementations$inte2","_type2","getDirectives","getDirective","toConfig","_this$extensionASTNod","slice","get","typeSet","has","add","_i20","_namedType$getTypes2","memberType","_i22","_namedType$getInterfa6","_i24","_objectValues2","getFields","field","_i26","_field$args2","_i28","_objectValues4","_field"],"mappings":"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","sourcesContent":["function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport find from \"../polyfills/find.mjs\";\nimport arrayFrom from \"../polyfills/arrayFrom.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport toObjMap from \"../jsutils/toObjMap.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { __Schema } from \"./introspection.mjs\";\nimport { GraphQLDirective, isDirective, specifiedDirectives } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from \"./definition.mjs\";\n/**\n * Test if the given value is a GraphQL schema.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n\n  return schema;\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\nexport var GraphQLSchema = /*#__PURE__*/function () {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    var _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(0, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(0, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n    !config.directives || Array.isArray(config.directives) || devAssert(0, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    var allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n        var type = _config$types2[_i2];\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {\n      var directive = _this$_directives2[_i4];\n\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n          var arg = _directive$args2[_i6];\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (var _i8 = 0, _arrayFrom2 = arrayFrom(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {\n      var namedType = _arrayFrom2[_i8];\n\n      if (namedType == null) {\n        continue;\n      }\n\n      var typeName = namedType.name;\n      typeName || devAssert(0, 'One of the provided types for building the Schema is missing a name.');\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(typeName, \"\\\".\"));\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {\n          var iface = _namedType$getInterfa2[_i10];\n\n          if (isInterfaceType(iface)) {\n            var implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {\n          var _iface = _namedType$getInterfa4[_i12];\n\n          if (isInterfaceType(_iface)) {\n            var _implementations = this._implementationsMap[_iface.name];\n\n            if (_implementations === undefined) {\n              _implementations = this._implementationsMap[_iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            _implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  };\n\n  _proto.getImplementations = function getImplementations(interfaceType) {\n    var implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  } // @deprecated: use isSubType instead - will be removed in v16.\n  ;\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    return this.isSubType(abstractType, possibleType);\n  };\n\n  _proto.isSubType = function isSubType(abstractType, maybeSubType) {\n    var map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {\n          var type = _abstractType$getType2[_i14];\n          map[type.name] = true;\n        }\n      } else {\n        var implementations = this.getImplementations(abstractType);\n\n        for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {\n          var _type = _implementations$obje2[_i16];\n          map[_type.name] = true;\n        }\n\n        for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {\n          var _type2 = _implementations$inte2[_i18];\n          map[_type2.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return find(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  _proto.toConfig = function toConfig() {\n    var _this$extensionASTNod;\n\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: objectValues(this.getTypeMap()),\n      directives: this.getDirectives().slice(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],\n      assumeValid: this.__validationErrors !== undefined\n    };\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n  ;\n\n  _createClass(GraphQLSchema, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'GraphQLSchema';\n    }\n  }]);\n\n  return GraphQLSchema;\n}();\n\nfunction collectReferencedTypes(type, typeSet) {\n  var namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {\n        var memberType = _namedType$getTypes2[_i20];\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {\n        var interfaceType = _namedType$getInterfa6[_i22];\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (var _i24 = 0, _objectValues2 = objectValues(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {\n        var field = _objectValues2[_i24];\n        collectReferencedTypes(field.type, typeSet);\n\n        for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {\n          var arg = _field$args2[_i26];\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (var _i28 = 0, _objectValues4 = objectValues(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {\n        var _field = _objectValues4[_i28];\n        collectReferencedTypes(_field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"]},"metadata":{},"sourceType":"module"}