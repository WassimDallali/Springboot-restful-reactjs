{"ast":null,"code":"var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode } from \"../../language/predicates.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../../type/definition.mjs\";\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), defNode ? [defNode, node] : node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected kind: ' + inspect(kind));\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"names":["_defKindToExtKind","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","inspect","invariant","didYouMean","suggestionList","GraphQLError","Kind","isTypeDefinitionNode","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","PossibleTypeExtensionsRule","context","schema","getSchema","definedTypes","create","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","typeName","defNode","existingType","getType","expectedKind","defKindToExtKind","kind","typeToExtKind","kindStr","extensionKindToTypeName","reportError","concat","allTypeNames","keys","getTypeMap","suggestedTypes","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type"],"mappings":"AAAA,IAAIA,iBAAJ;;AAEA,SAASC,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;AAAE,MAAID,GAAG,IAAID,GAAX,EAAgB;AAAEG,IAAAA,MAAM,CAACC,cAAP,CAAsBJ,GAAtB,EAA2BC,GAA3B,EAAgC;AAAEC,MAAAA,KAAK,EAAEA,KAAT;AAAgBG,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEP,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AAAmB;;AAAC,SAAOF,GAAP;AAAa;;AAEjN,OAAOQ,OAAP,MAAoB,2BAApB;AACA,OAAOC,SAAP,MAAsB,6BAAtB;AACA,OAAOC,UAAP,MAAuB,8BAAvB;AACA,OAAOC,cAAP,MAA2B,kCAA3B;AACA,SAASC,YAAT,QAA6B,8BAA7B;AACA,SAASC,IAAT,QAAqB,0BAArB;AACA,SAASC,oBAAT,QAAqC,+BAArC;AACA,SAASC,YAAT,EAAuBC,YAAvB,EAAqCC,eAArC,EAAsDC,WAAtD,EAAmEC,UAAnE,EAA+EC,iBAA/E,QAAwG,2BAAxG;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,0BAAT,CAAoCC,OAApC,EAA6C;AAClD,MAAIC,MAAM,GAAGD,OAAO,CAACE,SAAR,EAAb;AACA,MAAIC,YAAY,GAAGtB,MAAM,CAACuB,MAAP,CAAc,IAAd,CAAnB;;AAEA,OAAK,IAAIC,GAAG,GAAG,CAAV,EAAaC,sBAAsB,GAAGN,OAAO,CAACO,WAAR,GAAsBC,WAAjE,EAA8EH,GAAG,GAAGC,sBAAsB,CAACG,MAA3G,EAAmHJ,GAAG,EAAtH,EAA0H;AACxH,QAAIK,GAAG,GAAGJ,sBAAsB,CAACD,GAAD,CAAhC;;AAEA,QAAIb,oBAAoB,CAACkB,GAAD,CAAxB,EAA+B;AAC7BP,MAAAA,YAAY,CAACO,GAAG,CAACC,IAAJ,CAAS/B,KAAV,CAAZ,GAA+B8B,GAA/B;AACD;AACF;;AAED,SAAO;AACLE,IAAAA,mBAAmB,EAAEC,cADhB;AAELC,IAAAA,mBAAmB,EAAED,cAFhB;AAGLE,IAAAA,sBAAsB,EAAEF,cAHnB;AAILG,IAAAA,kBAAkB,EAAEH,cAJf;AAKLI,IAAAA,iBAAiB,EAAEJ,cALd;AAMLK,IAAAA,wBAAwB,EAAEL;AANrB,GAAP;;AASA,WAASA,cAAT,CAAwBM,IAAxB,EAA8B;AAC5B,QAAIC,QAAQ,GAAGD,IAAI,CAACR,IAAL,CAAU/B,KAAzB;AACA,QAAIyC,OAAO,GAAGlB,YAAY,CAACiB,QAAD,CAA1B;AACA,QAAIE,YAAY,GAAGrB,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACsB,OAAP,CAAeH,QAAf,CAAnE;AACA,QAAII,YAAJ;;AAEA,QAAIH,OAAJ,EAAa;AACXG,MAAAA,YAAY,GAAGC,gBAAgB,CAACJ,OAAO,CAACK,IAAT,CAA/B;AACD,KAFD,MAEO,IAAIJ,YAAJ,EAAkB;AACvBE,MAAAA,YAAY,GAAGG,aAAa,CAACL,YAAD,CAA5B;AACD;;AAED,QAAIE,YAAJ,EAAkB;AAChB,UAAIA,YAAY,KAAKL,IAAI,CAACO,IAA1B,EAAgC;AAC9B,YAAIE,OAAO,GAAGC,uBAAuB,CAACV,IAAI,CAACO,IAAN,CAArC;AACA1B,QAAAA,OAAO,CAAC8B,WAAR,CAAoB,IAAIxC,YAAJ,CAAiB,qBAAqByC,MAArB,CAA4BH,OAA5B,EAAqC,UAArC,EAAiDG,MAAjD,CAAwDX,QAAxD,EAAkE,KAAlE,CAAjB,EAA2FC,OAAO,GAAG,CAACA,OAAD,EAAUF,IAAV,CAAH,GAAqBA,IAAvH,CAApB;AACD;AACF,KALD,MAKO;AACL,UAAIa,YAAY,GAAGnD,MAAM,CAACoD,IAAP,CAAY9B,YAAZ,CAAnB;;AAEA,UAAIF,MAAJ,EAAY;AACV+B,QAAAA,YAAY,GAAGA,YAAY,CAACD,MAAb,CAAoBlD,MAAM,CAACoD,IAAP,CAAYhC,MAAM,CAACiC,UAAP,EAAZ,CAApB,CAAf;AACD;;AAED,UAAIC,cAAc,GAAG9C,cAAc,CAAC+B,QAAD,EAAWY,YAAX,CAAnC;AACAhC,MAAAA,OAAO,CAAC8B,WAAR,CAAoB,IAAIxC,YAAJ,CAAiB,wBAAwByC,MAAxB,CAA+BX,QAA/B,EAAyC,+BAAzC,IAA4EhC,UAAU,CAAC+C,cAAD,CAAvG,EAAyHhB,IAAI,CAACR,IAA9H,CAApB;AACD;AACF;AACF;AACD,IAAIc,gBAAgB,IAAIjD,iBAAiB,GAAG,EAApB,EAAwBC,eAAe,CAACD,iBAAD,EAAoBe,IAAI,CAAC6C,sBAAzB,EAAiD7C,IAAI,CAAC8C,qBAAtD,CAAvC,EAAqH5D,eAAe,CAACD,iBAAD,EAAoBe,IAAI,CAAC+C,sBAAzB,EAAiD/C,IAAI,CAACgD,qBAAtD,CAApI,EAAkN9D,eAAe,CAACD,iBAAD,EAAoBe,IAAI,CAACiD,yBAAzB,EAAoDjD,IAAI,CAACkD,wBAAzD,CAAjO,EAAqThE,eAAe,CAACD,iBAAD,EAAoBe,IAAI,CAACmD,qBAAzB,EAAgDnD,IAAI,CAACoD,oBAArD,CAApU,EAAgZlE,eAAe,CAACD,iBAAD,EAAoBe,IAAI,CAACqD,oBAAzB,EAA+CrD,IAAI,CAACsD,mBAApD,CAA/Z,EAAyepE,eAAe,CAACD,iBAAD,EAAoBe,IAAI,CAACuD,4BAAzB,EAAuDvD,IAAI,CAACwD,2BAA5D,CAAxf,EAAklBvE,iBAAtlB,CAApB;;AAEA,SAASmD,aAAT,CAAuBqB,IAAvB,EAA6B;AAC3B,MAAIvD,YAAY,CAACuD,IAAD,CAAhB,EAAwB;AACtB,WAAOzD,IAAI,CAAC8C,qBAAZ;AACD;;AAED,MAAI3C,YAAY,CAACsD,IAAD,CAAhB,EAAwB;AACtB,WAAOzD,IAAI,CAACgD,qBAAZ;AACD;;AAED,MAAI5C,eAAe,CAACqD,IAAD,CAAnB,EAA2B;AACzB,WAAOzD,IAAI,CAACkD,wBAAZ;AACD;;AAED,MAAI7C,WAAW,CAACoD,IAAD,CAAf,EAAuB;AACrB,WAAOzD,IAAI,CAACoD,oBAAZ;AACD;;AAED,MAAI9C,UAAU,CAACmD,IAAD,CAAd,EAAsB;AACpB,WAAOzD,IAAI,CAACsD,mBAAZ;AACD,GAnB0B,CAmBzB;;;AAGF,MAAI/C,iBAAiB,CAACkD,IAAD,CAArB,EAA6B;AAC3B,WAAOzD,IAAI,CAACwD,2BAAZ;AACD,GAxB0B,CAwBzB;;;AAGF,WAAS5D,SAAS,CAAC,CAAD,EAAI,sBAAsBD,OAAO,CAAC8D,IAAD,CAAjC,CAAlB;AACD;;AAED,SAASnB,uBAAT,CAAiCH,IAAjC,EAAuC;AACrC,UAAQA,IAAR;AACE,SAAKnC,IAAI,CAAC8C,qBAAV;AACE,aAAO,QAAP;;AAEF,SAAK9C,IAAI,CAACgD,qBAAV;AACE,aAAO,QAAP;;AAEF,SAAKhD,IAAI,CAACkD,wBAAV;AACE,aAAO,WAAP;;AAEF,SAAKlD,IAAI,CAACoD,oBAAV;AACE,aAAO,OAAP;;AAEF,SAAKpD,IAAI,CAACsD,mBAAV;AACE,aAAO,MAAP;;AAEF,SAAKtD,IAAI,CAACwD,2BAAV;AACE,aAAO,cAAP;AAjBJ,GADqC,CAmBnC;;;AAGF,WAAS5D,SAAS,CAAC,CAAD,EAAI,sBAAsBD,OAAO,CAACwC,IAAD,CAAjC,CAAlB;AACD","sourcesContent":["var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode } from \"../../language/predicates.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), defNode ? [defNode, node] : node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected kind: ' + inspect(kind));\n}\n"]},"metadata":{},"sourceType":"module"}