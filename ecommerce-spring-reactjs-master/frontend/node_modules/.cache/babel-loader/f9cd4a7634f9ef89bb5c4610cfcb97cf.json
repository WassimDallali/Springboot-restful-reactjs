{"ast":null,"code":"import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"],"names":["GraphQLError","NoFragmentCyclesRule","context","visitedFrags","Object","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","detectCycleRecursive","fragment","name","value","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","length","_i2","spreadNode","spreadName","cycleIndex","push","undefined","spreadFragment","getFragment","cyclePath","slice","viaPath","map","s","join","reportError","concat","pop"],"mappings":"AAAA,SAASA,YAAT,QAA6B,8BAA7B;AACA,OAAO,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;AAC5C;AACA;AACA,MAAIC,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAnB,CAH4C,CAGJ;;AAExC,MAAIC,UAAU,GAAG,EAAjB,CAL4C,CAKvB;;AAErB,MAAIC,qBAAqB,GAAGH,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5B;AACA,SAAO;AACLG,IAAAA,mBAAmB,EAAE,SAASA,mBAAT,GAA+B;AAClD,aAAO,KAAP;AACD,KAHI;AAILC,IAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4BC,IAA5B,EAAkC;AACpDC,MAAAA,oBAAoB,CAACD,IAAD,CAApB;AACA,aAAO,KAAP;AACD;AAPI,GAAP,CAR4C,CAgBzC;AACH;AACA;;AAEA,WAASC,oBAAT,CAA8BC,QAA9B,EAAwC;AACtC,QAAIT,YAAY,CAACS,QAAQ,CAACC,IAAT,CAAcC,KAAf,CAAhB,EAAuC;AACrC;AACD;;AAED,QAAIC,YAAY,GAAGH,QAAQ,CAACC,IAAT,CAAcC,KAAjC;AACAX,IAAAA,YAAY,CAACY,YAAD,CAAZ,GAA6B,IAA7B;AACA,QAAIC,WAAW,GAAGd,OAAO,CAACe,kBAAR,CAA2BL,QAAQ,CAACM,YAApC,CAAlB;;AAEA,QAAIF,WAAW,CAACG,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B;AACD;;AAEDZ,IAAAA,qBAAqB,CAACQ,YAAD,CAArB,GAAsCT,UAAU,CAACa,MAAjD;;AAEA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,WAAW,CAACG,MAApC,EAA4CC,GAAG,EAA/C,EAAmD;AACjD,UAAIC,UAAU,GAAGL,WAAW,CAACI,GAAD,CAA5B;AACA,UAAIE,UAAU,GAAGD,UAAU,CAACR,IAAX,CAAgBC,KAAjC;AACA,UAAIS,UAAU,GAAGhB,qBAAqB,CAACe,UAAD,CAAtC;AACAhB,MAAAA,UAAU,CAACkB,IAAX,CAAgBH,UAAhB;;AAEA,UAAIE,UAAU,KAAKE,SAAnB,EAA8B;AAC5B,YAAIC,cAAc,GAAGxB,OAAO,CAACyB,WAAR,CAAoBL,UAApB,CAArB;;AAEA,YAAII,cAAJ,EAAoB;AAClBf,UAAAA,oBAAoB,CAACe,cAAD,CAApB;AACD;AACF,OAND,MAMO;AACL,YAAIE,SAAS,GAAGtB,UAAU,CAACuB,KAAX,CAAiBN,UAAjB,CAAhB;AACA,YAAIO,OAAO,GAAGF,SAAS,CAACC,KAAV,CAAgB,CAAhB,EAAmB,CAAC,CAApB,EAAuBE,GAAvB,CAA2B,UAAUC,CAAV,EAAa;AACpD,iBAAO,MAAMA,CAAC,CAACnB,IAAF,CAAOC,KAAb,GAAqB,GAA5B;AACD,SAFa,EAEXmB,IAFW,CAEN,IAFM,CAAd;AAGA/B,QAAAA,OAAO,CAACgC,WAAR,CAAoB,IAAIlC,YAAJ,CAAiB,4BAA4BmC,MAA5B,CAAmCb,UAAnC,EAA+C,kBAA/C,KAAsEQ,OAAO,KAAK,EAAZ,GAAiB,QAAQK,MAAR,CAAeL,OAAf,EAAwB,GAAxB,CAAjB,GAAgD,GAAtH,CAAjB,EAA6IF,SAA7I,CAApB;AACD;;AAEDtB,MAAAA,UAAU,CAAC8B,GAAX;AACD;;AAED7B,IAAAA,qBAAqB,CAACQ,YAAD,CAArB,GAAsCU,SAAtC;AACD;AACF","sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}