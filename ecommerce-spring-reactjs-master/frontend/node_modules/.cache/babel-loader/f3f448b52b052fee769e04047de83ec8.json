{"ast":null,"code":"import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"],"names":["GraphQLError","Kind","isTypeDefinitionNode","isTypeExtensionNode","specifiedDirectives","UniqueDirectivesPerLocationRule","context","uniqueDirectiveMap","Object","create","schema","getSchema","definedDirectives","getDirectives","_i2","length","directive","name","isRepeatable","astDefinitions","getDocument","definitions","_i4","def","kind","DIRECTIVE_DEFINITION","value","repeatable","schemaDirectives","typeDirectivesMap","enter","node","directives","seenDirectives","SCHEMA_DEFINITION","SCHEMA_EXTENSION","typeName","undefined","_i6","_node$directives2","_directive","directiveName","reportError","concat"],"mappings":"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","sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}