{"ast":null,"code":"import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/utilities/separateOperations.mjs"],"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","_i2","_documentAST$definiti2","definitions","length","definitionNode","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","value","collectDependencies","selectionSet","separatedDocumentASTs","_loop","_i4","operation","dependencies","Set","_i6","_collectDependencies2","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","_i8","toName","FragmentSpread"],"mappings":"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","sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}\n"]},"metadata":{},"sourceType":"module"}