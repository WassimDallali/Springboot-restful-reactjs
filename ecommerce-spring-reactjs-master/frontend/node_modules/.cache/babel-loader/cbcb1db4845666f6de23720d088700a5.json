{"ast":null,"code":"import { BYTE } from './byte';\nimport { FrameImpl } from './frame-impl';\nimport { Parser } from './parser';\nimport { StompSocketState } from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport class StompHandler {\n  constructor(_client, _webSocket, config = {}) {\n    this._client = _client;\n    this._webSocket = _webSocket;\n    this._serverFrameHandlers = {\n      // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n      CONNECTED: frame => {\n        this.debug(`connected to server ${frame.headers.server}`);\n        this._connected = true;\n        this._connectedVersion = frame.headers.version; // STOMP version 1.2 needs header values to be escaped\n\n        if (this._connectedVersion === Versions.V1_2) {\n          this._escapeHeaderValues = true;\n        }\n\n        this._setupHeartbeat(frame.headers);\n\n        this.onConnect(frame);\n      },\n      // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n      MESSAGE: frame => {\n        // the callback is registered when the client calls\n        // `subscribe()`.\n        // If there is no registered subscription for the received message,\n        // the default `onUnhandledMessage` callback is used that the client can set.\n        // This is useful for subscriptions that are automatically created\n        // on the browser side (e.g. [RabbitMQ's temporary\n        // queues](http://www.rabbitmq.com/stomp.html)).\n        const subscription = frame.headers.subscription;\n        const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage; // bless the frame to be a Message\n\n        const message = frame;\n        const client = this;\n        const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id']; // add `ack()` and `nack()` methods directly to the returned frame\n        // so that a simple call to `message.ack()` can acknowledge the message.\n\n        message.ack = (headers = {}) => {\n          return client.ack(messageId, subscription, headers);\n        };\n\n        message.nack = (headers = {}) => {\n          return client.nack(messageId, subscription, headers);\n        };\n\n        onReceive(message);\n      },\n      // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n      RECEIPT: frame => {\n        const callback = this._receiptWatchers[frame.headers['receipt-id']];\n\n        if (callback) {\n          callback(frame); // Server will acknowledge only once, remove the callback\n\n          delete this._receiptWatchers[frame.headers['receipt-id']];\n        } else {\n          this.onUnhandledReceipt(frame);\n        }\n      },\n      // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n      ERROR: frame => {\n        this.onStompError(frame);\n      }\n    }; // used to index subscribers\n\n    this._counter = 0; // subscription callbacks indexed by subscriber's ID\n\n    this._subscriptions = {}; // receipt-watchers indexed by receipts-ids\n\n    this._receiptWatchers = {};\n    this._partialData = '';\n    this._escapeHeaderValues = false;\n    this._lastServerActivityTS = Date.now();\n    this.configure(config);\n  }\n\n  get connectedVersion() {\n    return this._connectedVersion;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  configure(conf) {\n    // bulk assign all properties to this\n    Object.assign(this, conf);\n  }\n\n  start() {\n    const parser = new Parser( // On Frame\n    rawFrame => {\n      const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues); // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n\n      if (!this.logRawCommunication) {\n        this.debug(`<<< ${frame}`);\n      }\n\n      const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n      serverFrameHandler(frame);\n    }, // On Incoming Ping\n    () => {\n      this.debug('<<< PONG');\n    });\n\n    this._webSocket.onmessage = evt => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      if (this.logRawCommunication) {\n        const rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n\n      parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n    };\n\n    this._onclose = closeEvent => {\n      this.debug(`Connection closed to ${this._client.brokerURL}`);\n\n      this._cleanUp();\n\n      this.onWebSocketClose(closeEvent);\n    };\n\n    this._webSocket.onclose = this._onclose;\n\n    this._webSocket.onerror = errorEvent => {\n      this.onWebSocketError(errorEvent);\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = Object.assign({}, this.connectHeaders);\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n\n      this._transmit({\n        command: 'CONNECT',\n        headers: connectHeaders\n      });\n    };\n  }\n\n  _setupHeartbeat(headers) {\n    if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n      return;\n    } // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n\n\n    if (!headers['heart-beat']) {\n      return;\n    } // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n\n\n    const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map(v => parseInt(v, 10));\n\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n\n          this.debug('>>> PING');\n        }\n      }, ttl);\n    }\n\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS; // We wait twice the TTL to be flexible on window's setInterval calls\n\n\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n\n  _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug(\"Discarding websocket, the underlying socket may linger for a while\");\n\n      this._discardWebsocket();\n    } else {\n      this.debug(\"Issuing close on the websocket\");\n\n      this._closeWebsocket();\n    }\n  }\n\n  forceDisconnect() {\n    if (this._webSocket) {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n\n  _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n\n\n    this._webSocket.close();\n  }\n\n  _discardWebsocket() {\n    if (!this._webSocket.terminate) {\n      augmentWebsocket(this._webSocket, msg => this.debug(msg));\n    }\n\n    this._webSocket.terminate();\n  }\n\n  _transmit(params) {\n    const {\n      command,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader\n    });\n    let rawChunk = frame.serialize();\n\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk;\n\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n\n        this._webSocket.send(chunk);\n\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n\n  dispose() {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n\n          this._cleanUp();\n\n          this.onDisconnect(frame);\n        });\n\n        this._transmit({\n          command: 'DISCONNECT',\n          headers: disconnectHeaders\n        });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeWebsocket();\n      }\n    }\n  }\n\n  _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      clearInterval(this._pinger);\n    }\n\n    if (this._ponger) {\n      clearInterval(this._ponger);\n    }\n  }\n\n  publish(params) {\n    const {\n      destination,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const hdrs = Object.assign({\n      destination\n    }, headers);\n\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    });\n  }\n\n  watchForReceipt(receiptId, callback) {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  subscribe(destination, callback, headers = {}) {\n    headers = Object.assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n\n    this._transmit({\n      command: 'SUBSCRIBE',\n      headers\n    });\n\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      }\n\n    };\n  }\n\n  unsubscribe(id, headers = {}) {\n    headers = Object.assign({}, headers);\n    delete this._subscriptions[id];\n    headers.id = id;\n\n    this._transmit({\n      command: 'UNSUBSCRIBE',\n      headers\n    });\n  }\n\n  begin(transactionId) {\n    const txId = transactionId || `tx-${this._counter++}`;\n\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId\n      }\n    });\n\n    const client = this;\n    return {\n      id: txId,\n\n      commit() {\n        client.commit(txId);\n      },\n\n      abort() {\n        client.abort(txId);\n      }\n\n    };\n  }\n\n  commit(transactionId) {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  abort(transactionId) {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  ack(messageId, subscriptionId, headers = {}) {\n    headers = Object.assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n\n    headers.subscription = subscriptionId;\n\n    this._transmit({\n      command: 'ACK',\n      headers\n    });\n  }\n\n  nack(messageId, subscriptionId, headers = {}) {\n    headers = Object.assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n\n    headers.subscription = subscriptionId;\n    return this._transmit({\n      command: 'NACK',\n      headers\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/stomp-handler.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAqB,QAArB;AAEA,SAAS,SAAT,QAA0B,cAA1B;AAGA,SAAS,MAAT,QAAuB,UAAvB;AAIA,SAQE,gBARF,QAUO,SAVP;AAWA,SAAS,QAAT,QAAyB,YAAzB;AACA,SAAS,gBAAT,QAAiC,qBAAjC;AAEA;;;;;;AAMG;;AACH,OAAM,MAAO,YAAP,CAAmB;AA+DvB,EAAA,WAAA,CACU,OADV,EAES,UAFT,EAGE,MAAA,GAAsB,EAHxB,EAG0B;AAFhB,SAAA,OAAA,GAAA,OAAA;AACD,SAAA,UAAA,GAAA,UAAA;AA2FQ,SAAA,oBAAA,GAEb;AACF;AACA,MAAA,SAAS,EAAE,KAAK,IAAG;AACjB,aAAK,KAAL,CAAW,uBAAuB,KAAK,CAAC,OAAN,CAAc,MAAM,EAAtD;AACA,aAAK,UAAL,GAAkB,IAAlB;AACA,aAAK,iBAAL,GAAyB,KAAK,CAAC,OAAN,CAAc,OAAvC,CAHiB,CAIjB;;AACA,YAAI,KAAK,iBAAL,KAA2B,QAAQ,CAAC,IAAxC,EAA8C;AAC5C,eAAK,mBAAL,GAA2B,IAA3B;AACD;;AAED,aAAK,eAAL,CAAqB,KAAK,CAAC,OAA3B;;AACA,aAAK,SAAL,CAAe,KAAf;AACD,OAbC;AAeF;AACA,MAAA,OAAO,EAAE,KAAK,IAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM,YAAY,GAAG,KAAK,CAAC,OAAN,CAAc,YAAnC;AACA,cAAM,SAAS,GACb,KAAK,cAAL,CAAoB,YAApB,KAAqC,KAAK,kBAD5C,CATe,CAYf;;AACA,cAAM,OAAO,GAAG,KAAhB;AAEA,cAAM,MAAM,GAAG,IAAf;AACA,cAAM,SAAS,GACb,KAAK,iBAAL,KAA2B,QAAQ,CAAC,IAApC,GACI,OAAO,CAAC,OAAR,CAAgB,GADpB,GAEI,OAAO,CAAC,OAAR,CAAgB,YAAhB,CAHN,CAhBe,CAqBf;AACA;;AACA,QAAA,OAAO,CAAC,GAAR,GAAc,CAAC,OAAA,GAAwB,EAAzB,KAAqC;AACjD,iBAAO,MAAM,CAAC,GAAP,CAAW,SAAX,EAAsB,YAAtB,EAAoC,OAApC,CAAP;AACD,SAFD;;AAGA,QAAA,OAAO,CAAC,IAAR,GAAe,CAAC,OAAA,GAAwB,EAAzB,KAAqC;AAClD,iBAAO,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,YAAvB,EAAqC,OAArC,CAAP;AACD,SAFD;;AAGA,QAAA,SAAS,CAAC,OAAD,CAAT;AACD,OA9CC;AAgDF;AACA,MAAA,OAAO,EAAE,KAAK,IAAG;AACf,cAAM,QAAQ,GAAG,KAAK,gBAAL,CAAsB,KAAK,CAAC,OAAN,CAAc,YAAd,CAAtB,CAAjB;;AACA,YAAI,QAAJ,EAAc;AACZ,UAAA,QAAQ,CAAC,KAAD,CAAR,CADY,CAEZ;;AACA,iBAAO,KAAK,gBAAL,CAAsB,KAAK,CAAC,OAAN,CAAc,YAAd,CAAtB,CAAP;AACD,SAJD,MAIO;AACL,eAAK,kBAAL,CAAwB,KAAxB;AACD;AACF,OA1DC;AA4DF;AACA,MAAA,KAAK,EAAE,KAAK,IAAG;AACb,aAAK,YAAL,CAAkB,KAAlB;AACD;AA/DC,KAFa,CA1FS,CAExB;;AACA,SAAK,QAAL,GAAgB,CAAhB,CAHwB,CAKxB;;AACA,SAAK,cAAL,GAAsB,EAAtB,CANwB,CAQxB;;AACA,SAAK,gBAAL,GAAwB,EAAxB;AAEA,SAAK,YAAL,GAAoB,EAApB;AAEA,SAAK,mBAAL,GAA2B,KAA3B;AAEA,SAAK,qBAAL,GAA6B,IAAI,CAAC,GAAL,EAA7B;AAEA,SAAK,SAAL,CAAe,MAAf;AACD;;AA3CmB,MAAhB,gBAAgB,GAAA;AAClB,WAAO,KAAK,iBAAZ;AACD;;AAGY,MAAT,SAAS,GAAA;AACX,WAAO,KAAK,UAAZ;AACD;;AAsCM,EAAA,SAAS,CAAC,IAAD,EAAkB;AAChC;AACC,IAAA,MAAc,CAAC,MAAf,CAAsB,IAAtB,EAA4B,IAA5B;AACF;;AAEM,EAAA,KAAK,GAAA;AACV,UAAM,MAAM,GAAG,IAAI,MAAJ,EACb;AACA,IAAA,QAAQ,IAAG;AACT,YAAM,KAAK,GAAG,SAAS,CAAC,YAAV,CACZ,QADY,EAEZ,KAAK,mBAFO,CAAd,CADS,CAMT;;AACA,UAAI,CAAC,KAAK,mBAAV,EAA+B;AAC7B,aAAK,KAAL,CAAW,OAAO,KAAK,EAAvB;AACD;;AAED,YAAM,kBAAkB,GACtB,KAAK,oBAAL,CAA0B,KAAK,CAAC,OAAhC,KAA4C,KAAK,gBADnD;AAEA,MAAA,kBAAkB,CAAC,KAAD,CAAlB;AACD,KAhBY,EAiBb;AACA,UAAK;AACH,WAAK,KAAL,CAAW,UAAX;AACD,KApBY,CAAf;;AAuBA,SAAK,UAAL,CAAgB,SAAhB,GAA6B,GAAD,IAAkC;AAC5D,WAAK,KAAL,CAAW,eAAX;AACA,WAAK,qBAAL,GAA6B,IAAI,CAAC,GAAL,EAA7B;;AAEA,UAAI,KAAK,mBAAT,EAA8B;AAC5B,cAAM,gBAAgB,GACpB,GAAG,CAAC,IAAJ,YAAoB,WAApB,GACI,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,GAAG,CAAC,IAA7B,CADJ,GAEI,GAAG,CAAC,IAHV;AAIA,aAAK,KAAL,CAAW,OAAO,gBAAgB,EAAlC;AACD;;AAED,MAAA,MAAM,CAAC,UAAP,CAAkB,GAAG,CAAC,IAAtB,EAA4B,KAAK,2BAAjC;AACD,KAbD;;AAeA,SAAK,QAAL,GAAiB,UAAD,IAAqB;AACnC,WAAK,KAAL,CAAW,wBAAwB,KAAK,OAAL,CAAa,SAAS,EAAzD;;AACA,WAAK,QAAL;;AACA,WAAK,gBAAL,CAAsB,UAAtB;AACD,KAJD;;AAMA,SAAK,UAAL,CAAgB,OAAhB,GAA0B,KAAK,QAA/B;;AAEA,SAAK,UAAL,CAAgB,OAAhB,GAA2B,UAAD,IAAqB;AAC7C,WAAK,gBAAL,CAAsB,UAAtB;AACD,KAFD;;AAIA,SAAK,UAAL,CAAgB,MAAhB,GAAyB,MAAK;AAC5B;AACA,YAAM,cAAc,GAAI,MAAc,CAAC,MAAf,CAAsB,EAAtB,EAA0B,KAAK,cAA/B,CAAxB;AAEA,WAAK,KAAL,CAAW,sBAAX;AACA,MAAA,cAAc,CAAC,gBAAD,CAAd,GAAmC,KAAK,aAAL,CAAmB,iBAAnB,EAAnC;AACA,MAAA,cAAc,CAAC,YAAD,CAAd,GAA+B,CAC7B,KAAK,iBADwB,EAE7B,KAAK,iBAFwB,EAG7B,IAH6B,CAGxB,GAHwB,CAA/B;;AAIA,WAAK,SAAL,CAAe;AAAE,QAAA,OAAO,EAAE,SAAX;AAAsB,QAAA,OAAO,EAAE;AAA/B,OAAf;AACD,KAXD;AAYD;;AAsEO,EAAA,eAAe,CAAC,OAAD,EAAsB;AAC3C,QACE,OAAO,CAAC,OAAR,KAAoB,QAAQ,CAAC,IAA7B,IACA,OAAO,CAAC,OAAR,KAAoB,QAAQ,CAAC,IAF/B,EAGE;AACA;AACD,KAN0C,CAQ3C;AACA;;;AACA,QAAI,CAAC,OAAO,CAAC,YAAD,CAAZ,EAA4B;AAC1B;AACD,KAZ0C,CAc3C;AACA;AACA;;;AACA,UAAM,CAAC,cAAD,EAAiB,cAAjB,IAAmC,OAAO,CAAC,YAAD,CAAP,CACtC,KADsC,CAChC,GADgC,EAEtC,GAFsC,CAEjC,CAAD,IAAe,QAAQ,CAAC,CAAD,EAAI,EAAJ,CAFW,CAAzC;;AAIA,QAAI,KAAK,iBAAL,KAA2B,CAA3B,IAAgC,cAAc,KAAK,CAAvD,EAA0D;AACxD,YAAM,GAAG,GAAW,IAAI,CAAC,GAAL,CAAS,KAAK,iBAAd,EAAiC,cAAjC,CAApB;AACA,WAAK,KAAL,CAAW,mBAAmB,GAAG,IAAjC;AACA,WAAK,OAAL,GAAe,WAAW,CAAC,MAAK;AAC9B,YAAI,KAAK,UAAL,CAAgB,UAAhB,KAA+B,gBAAgB,CAAC,IAApD,EAA0D;AACxD,eAAK,UAAL,CAAgB,IAAhB,CAAqB,IAAI,CAAC,EAA1B;;AACA,eAAK,KAAL,CAAW,UAAX;AACD;AACF,OALyB,EAKvB,GALuB,CAA1B;AAMD;;AAED,QAAI,KAAK,iBAAL,KAA2B,CAA3B,IAAgC,cAAc,KAAK,CAAvD,EAA0D;AACxD,YAAM,GAAG,GAAW,IAAI,CAAC,GAAL,CAAS,KAAK,iBAAd,EAAiC,cAAjC,CAApB;AACA,WAAK,KAAL,CAAW,oBAAoB,GAAG,IAAlC;AACA,WAAK,OAAL,GAAe,WAAW,CAAC,MAAK;AAC9B,cAAM,KAAK,GAAG,IAAI,CAAC,GAAL,KAAa,KAAK,qBAAhC,CAD8B,CAE9B;;;AACA,YAAI,KAAK,GAAG,GAAG,GAAG,CAAlB,EAAqB;AACnB,eAAK,KAAL,CAAW,gDAAgD,KAAK,IAAhE;;AACA,eAAK,wBAAL;AACD;AACF,OAPyB,EAOvB,GAPuB,CAA1B;AAQD;AACF;;AAEO,EAAA,wBAAwB,GAAA;AAC9B,QAAI,KAAK,6BAAT,EAAwC;AACtC,WAAK,KAAL,CACE,oEADF;;AAGA,WAAK,iBAAL;AACD,KALD,MAKO;AACL,WAAK,KAAL,CAAW,gCAAX;;AACA,WAAK,eAAL;AACD;AACF;;AAEM,EAAA,eAAe,GAAA;AACpB,QAAI,KAAK,UAAT,EAAqB;AACnB,UACE,KAAK,UAAL,CAAgB,UAAhB,KAA+B,gBAAgB,CAAC,UAAhD,IACA,KAAK,UAAL,CAAgB,UAAhB,KAA+B,gBAAgB,CAAC,IAFlD,EAGE;AACA,aAAK,wBAAL;AACD;AACF;AACF;;AAEM,EAAA,eAAe,GAAA;AACpB,SAAK,UAAL,CAAgB,SAAhB,GAA4B,MAAK,CAAG,CAApC,CADoB,CACkB;;;AACtC,SAAK,UAAL,CAAgB,KAAhB;AACD;;AAEO,EAAA,iBAAiB,GAAA;AACvB,QAAI,CAAC,KAAK,UAAL,CAAgB,SAArB,EAAgC;AAC9B,MAAA,gBAAgB,CAAC,KAAK,UAAN,EAAmB,GAAD,IAAiB,KAAK,KAAL,CAAW,GAAX,CAAnC,CAAhB;AACD;;AAED,SAAK,UAAL,CAAgB,SAAhB;AACD;;AAEO,EAAA,SAAS,CAAC,MAAD,EAMhB;AACC,UAAM;AACJ,MAAA,OADI;AAEJ,MAAA,OAFI;AAGJ,MAAA,IAHI;AAIJ,MAAA,UAJI;AAKJ,MAAA;AALI,QAMF,MANJ;AAOA,UAAM,KAAK,GAAG,IAAI,SAAJ,CAAc;AAC1B,MAAA,OAD0B;AAE1B,MAAA,OAF0B;AAG1B,MAAA,IAH0B;AAI1B,MAAA,UAJ0B;AAK1B,MAAA,kBAAkB,EAAE,KAAK,mBALC;AAM1B,MAAA;AAN0B,KAAd,CAAd;AASA,QAAI,QAAQ,GAAG,KAAK,CAAC,SAAN,EAAf;;AAEA,QAAI,KAAK,mBAAT,EAA8B;AAC5B,WAAK,KAAL,CAAW,OAAO,QAAQ,EAA1B;AACD,KAFD,MAEO;AACL,WAAK,KAAL,CAAW,OAAO,KAAK,EAAvB;AACD;;AAED,QAAI,KAAK,mBAAL,IAA4B,OAAO,QAAP,KAAoB,QAApD,EAA8D;AAC5D,MAAA,QAAQ,GAAG,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,QAAzB,CAAX;AACD;;AAED,QAAI,OAAO,QAAP,KAAoB,QAApB,IAAgC,CAAC,KAAK,gBAA1C,EAA4D;AAC1D,WAAK,UAAL,CAAgB,IAAhB,CAAqB,QAArB;AACD,KAFD,MAEO;AACL,UAAI,GAAG,GAAG,QAAV;;AACA,aAAO,GAAG,CAAC,MAAJ,GAAa,CAApB,EAAuB;AACrB,cAAM,KAAK,GAAG,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,KAAK,qBAAtB,CAAd;AACA,QAAA,GAAG,GAAG,GAAG,CAAC,SAAJ,CAAc,KAAK,qBAAnB,CAAN;;AACA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,KAArB;;AACA,aAAK,KAAL,CAAW,gBAAgB,KAAK,CAAC,MAAM,iBAAiB,GAAG,CAAC,MAAM,EAAlE;AACD;AACF;AACF;;AAEM,EAAA,OAAO,GAAA;AACZ,QAAI,KAAK,SAAT,EAAoB;AAClB,UAAI;AACF;AACA,cAAM,iBAAiB,GAAI,MAAc,CAAC,MAAf,CACzB,EADyB,EAEzB,KAAK,iBAFoB,CAA3B;;AAKA,YAAI,CAAC,iBAAiB,CAAC,OAAvB,EAAgC;AAC9B,UAAA,iBAAiB,CAAC,OAAlB,GAA4B,SAAS,KAAK,QAAL,EAAe,EAApD;AACD;;AACD,aAAK,eAAL,CAAqB,iBAAiB,CAAC,OAAvC,EAAgD,KAAK,IAAG;AACtD,eAAK,eAAL;;AACA,eAAK,QAAL;;AACA,eAAK,YAAL,CAAkB,KAAlB;AACD,SAJD;;AAKA,aAAK,SAAL,CAAe;AAAE,UAAA,OAAO,EAAE,YAAX;AAAyB,UAAA,OAAO,EAAE;AAAlC,SAAf;AACD,OAhBD,CAgBE,OAAO,KAAP,EAAc;AACd,aAAK,KAAL,CAAW,oCAAoC,KAAK,EAApD;AACD;AACF,KApBD,MAoBO;AACL,UACE,KAAK,UAAL,CAAgB,UAAhB,KAA+B,gBAAgB,CAAC,UAAhD,IACA,KAAK,UAAL,CAAgB,UAAhB,KAA+B,gBAAgB,CAAC,IAFlD,EAGE;AACA,aAAK,eAAL;AACD;AACF;AACF;;AAEO,EAAA,QAAQ,GAAA;AACd,SAAK,UAAL,GAAkB,KAAlB;;AAEA,QAAI,KAAK,OAAT,EAAkB;AAChB,MAAA,aAAa,CAAC,KAAK,OAAN,CAAb;AACD;;AACD,QAAI,KAAK,OAAT,EAAkB;AAChB,MAAA,aAAa,CAAC,KAAK,OAAN,CAAb;AACD;AACF;;AAEM,EAAA,OAAO,CAAC,MAAD,EAAuB;AACnC,UAAM;AACJ,MAAA,WADI;AAEJ,MAAA,OAFI;AAGJ,MAAA,IAHI;AAIJ,MAAA,UAJI;AAKJ,MAAA;AALI,QAMF,MANJ;AAOA,UAAM,IAAI,GAAkB,MAAc,CAAC,MAAf,CAAsB;AAAE,MAAA;AAAF,KAAtB,EAAuC,OAAvC,CAA5B;;AACA,SAAK,SAAL,CAAe;AACb,MAAA,OAAO,EAAE,MADI;AAEb,MAAA,OAAO,EAAE,IAFI;AAGb,MAAA,IAHa;AAIb,MAAA,UAJa;AAKb,MAAA;AALa,KAAf;AAOD;;AAEM,EAAA,eAAe,CAAC,SAAD,EAAoB,QAApB,EAA+C;AACnE,SAAK,gBAAL,CAAsB,SAAtB,IAAmC,QAAnC;AACD;;AAEM,EAAA,SAAS,CACd,WADc,EAEd,QAFc,EAGd,OAAA,GAAwB,EAHV,EAGY;AAE1B,IAAA,OAAO,GAAI,MAAc,CAAC,MAAf,CAAsB,EAAtB,EAA0B,OAA1B,CAAX;;AAEA,QAAI,CAAC,OAAO,CAAC,EAAb,EAAiB;AACf,MAAA,OAAO,CAAC,EAAR,GAAa,OAAO,KAAK,QAAL,EAAe,EAAnC;AACD;;AACD,IAAA,OAAO,CAAC,WAAR,GAAsB,WAAtB;AACA,SAAK,cAAL,CAAoB,OAAO,CAAC,EAA5B,IAAkC,QAAlC;;AACA,SAAK,SAAL,CAAe;AAAE,MAAA,OAAO,EAAE,WAAX;AAAwB,MAAA;AAAxB,KAAf;;AACA,UAAM,MAAM,GAAG,IAAf;AACA,WAAO;AACL,MAAA,EAAE,EAAE,OAAO,CAAC,EADP;;AAGL,MAAA,WAAW,CAAC,IAAD,EAAK;AACd,eAAO,MAAM,CAAC,WAAP,CAAmB,OAAO,CAAC,EAA3B,EAA+B,IAA/B,CAAP;AACD;;AALI,KAAP;AAOD;;AAEM,EAAA,WAAW,CAAC,EAAD,EAAa,OAAA,GAAwB,EAArC,EAAuC;AACvD,IAAA,OAAO,GAAI,MAAc,CAAC,MAAf,CAAsB,EAAtB,EAA0B,OAA1B,CAAX;AAEA,WAAO,KAAK,cAAL,CAAoB,EAApB,CAAP;AACA,IAAA,OAAO,CAAC,EAAR,GAAa,EAAb;;AACA,SAAK,SAAL,CAAe;AAAE,MAAA,OAAO,EAAE,aAAX;AAA0B,MAAA;AAA1B,KAAf;AACD;;AAEM,EAAA,KAAK,CAAC,aAAD,EAAsB;AAChC,UAAM,IAAI,GAAG,aAAa,IAAI,MAAM,KAAK,QAAL,EAAe,EAAnD;;AACA,SAAK,SAAL,CAAe;AACb,MAAA,OAAO,EAAE,OADI;AAEb,MAAA,OAAO,EAAE;AACP,QAAA,WAAW,EAAE;AADN;AAFI,KAAf;;AAMA,UAAM,MAAM,GAAG,IAAf;AACA,WAAO;AACL,MAAA,EAAE,EAAE,IADC;;AAEL,MAAA,MAAM,GAAA;AACJ,QAAA,MAAM,CAAC,MAAP,CAAc,IAAd;AACD,OAJI;;AAKL,MAAA,KAAK,GAAA;AACH,QAAA,MAAM,CAAC,KAAP,CAAa,IAAb;AACD;;AAPI,KAAP;AASD;;AAEM,EAAA,MAAM,CAAC,aAAD,EAAsB;AACjC,SAAK,SAAL,CAAe;AACb,MAAA,OAAO,EAAE,QADI;AAEb,MAAA,OAAO,EAAE;AACP,QAAA,WAAW,EAAE;AADN;AAFI,KAAf;AAMD;;AAEM,EAAA,KAAK,CAAC,aAAD,EAAsB;AAChC,SAAK,SAAL,CAAe;AACb,MAAA,OAAO,EAAE,OADI;AAEb,MAAA,OAAO,EAAE;AACP,QAAA,WAAW,EAAE;AADN;AAFI,KAAf;AAMD;;AAEM,EAAA,GAAG,CACR,SADQ,EAER,cAFQ,EAGR,OAAA,GAAwB,EAHhB,EAGkB;AAE1B,IAAA,OAAO,GAAI,MAAc,CAAC,MAAf,CAAsB,EAAtB,EAA0B,OAA1B,CAAX;;AAEA,QAAI,KAAK,iBAAL,KAA2B,QAAQ,CAAC,IAAxC,EAA8C;AAC5C,MAAA,OAAO,CAAC,EAAR,GAAa,SAAb;AACD,KAFD,MAEO;AACL,MAAA,OAAO,CAAC,YAAD,CAAP,GAAwB,SAAxB;AACD;;AACD,IAAA,OAAO,CAAC,YAAR,GAAuB,cAAvB;;AACA,SAAK,SAAL,CAAe;AAAE,MAAA,OAAO,EAAE,KAAX;AAAkB,MAAA;AAAlB,KAAf;AACD;;AAEM,EAAA,IAAI,CACT,SADS,EAET,cAFS,EAGT,OAAA,GAAwB,EAHf,EAGiB;AAE1B,IAAA,OAAO,GAAI,MAAc,CAAC,MAAf,CAAsB,EAAtB,EAA0B,OAA1B,CAAX;;AAEA,QAAI,KAAK,iBAAL,KAA2B,QAAQ,CAAC,IAAxC,EAA8C;AAC5C,MAAA,OAAO,CAAC,EAAR,GAAa,SAAb;AACD,KAFD,MAEO;AACL,MAAA,OAAO,CAAC,YAAD,CAAP,GAAwB,SAAxB;AACD;;AACD,IAAA,OAAO,CAAC,YAAR,GAAuB,cAAvB;AACA,WAAO,KAAK,SAAL,CAAe;AAAE,MAAA,OAAO,EAAE,MAAX;AAAmB,MAAA;AAAnB,KAAf,CAAP;AACD;;AArgBsB","sourceRoot":"","sourcesContent":["import { BYTE } from './byte';\nimport { FrameImpl } from './frame-impl';\nimport { Parser } from './parser';\nimport { StompSocketState, } from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n    constructor(_client, _webSocket, config = {}) {\n        this._client = _client;\n        this._webSocket = _webSocket;\n        this._serverFrameHandlers = {\n            // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n            CONNECTED: frame => {\n                this.debug(`connected to server ${frame.headers.server}`);\n                this._connected = true;\n                this._connectedVersion = frame.headers.version;\n                // STOMP version 1.2 needs header values to be escaped\n                if (this._connectedVersion === Versions.V1_2) {\n                    this._escapeHeaderValues = true;\n                }\n                this._setupHeartbeat(frame.headers);\n                this.onConnect(frame);\n            },\n            // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n            MESSAGE: frame => {\n                // the callback is registered when the client calls\n                // `subscribe()`.\n                // If there is no registered subscription for the received message,\n                // the default `onUnhandledMessage` callback is used that the client can set.\n                // This is useful for subscriptions that are automatically created\n                // on the browser side (e.g. [RabbitMQ's temporary\n                // queues](http://www.rabbitmq.com/stomp.html)).\n                const subscription = frame.headers.subscription;\n                const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n                // bless the frame to be a Message\n                const message = frame;\n                const client = this;\n                const messageId = this._connectedVersion === Versions.V1_2\n                    ? message.headers.ack\n                    : message.headers['message-id'];\n                // add `ack()` and `nack()` methods directly to the returned frame\n                // so that a simple call to `message.ack()` can acknowledge the message.\n                message.ack = (headers = {}) => {\n                    return client.ack(messageId, subscription, headers);\n                };\n                message.nack = (headers = {}) => {\n                    return client.nack(messageId, subscription, headers);\n                };\n                onReceive(message);\n            },\n            // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n            RECEIPT: frame => {\n                const callback = this._receiptWatchers[frame.headers['receipt-id']];\n                if (callback) {\n                    callback(frame);\n                    // Server will acknowledge only once, remove the callback\n                    delete this._receiptWatchers[frame.headers['receipt-id']];\n                }\n                else {\n                    this.onUnhandledReceipt(frame);\n                }\n            },\n            // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n            ERROR: frame => {\n                this.onStompError(frame);\n            },\n        };\n        // used to index subscribers\n        this._counter = 0;\n        // subscription callbacks indexed by subscriber's ID\n        this._subscriptions = {};\n        // receipt-watchers indexed by receipts-ids\n        this._receiptWatchers = {};\n        this._partialData = '';\n        this._escapeHeaderValues = false;\n        this._lastServerActivityTS = Date.now();\n        this.configure(config);\n    }\n    get connectedVersion() {\n        return this._connectedVersion;\n    }\n    get connected() {\n        return this._connected;\n    }\n    configure(conf) {\n        // bulk assign all properties to this\n        Object.assign(this, conf);\n    }\n    start() {\n        const parser = new Parser(\n        // On Frame\n        rawFrame => {\n            const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n            // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n            if (!this.logRawCommunication) {\n                this.debug(`<<< ${frame}`);\n            }\n            const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n            serverFrameHandler(frame);\n        }, \n        // On Incoming Ping\n        () => {\n            this.debug('<<< PONG');\n        });\n        this._webSocket.onmessage = (evt) => {\n            this.debug('Received data');\n            this._lastServerActivityTS = Date.now();\n            if (this.logRawCommunication) {\n                const rawChunkAsString = evt.data instanceof ArrayBuffer\n                    ? new TextDecoder().decode(evt.data)\n                    : evt.data;\n                this.debug(`<<< ${rawChunkAsString}`);\n            }\n            parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n        };\n        this._onclose = (closeEvent) => {\n            this.debug(`Connection closed to ${this._client.brokerURL}`);\n            this._cleanUp();\n            this.onWebSocketClose(closeEvent);\n        };\n        this._webSocket.onclose = this._onclose;\n        this._webSocket.onerror = (errorEvent) => {\n            this.onWebSocketError(errorEvent);\n        };\n        this._webSocket.onopen = () => {\n            // Clone before updating\n            const connectHeaders = Object.assign({}, this.connectHeaders);\n            this.debug('Web Socket Opened...');\n            connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n            connectHeaders['heart-beat'] = [\n                this.heartbeatOutgoing,\n                this.heartbeatIncoming,\n            ].join(',');\n            this._transmit({ command: 'CONNECT', headers: connectHeaders });\n        };\n    }\n    _setupHeartbeat(headers) {\n        if (headers.version !== Versions.V1_1 &&\n            headers.version !== Versions.V1_2) {\n            return;\n        }\n        // It is valid for the server to not send this header\n        // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n        if (!headers['heart-beat']) {\n            return;\n        }\n        // heart-beat header received from the server looks like:\n        //\n        //     heart-beat: sx, sy\n        const [serverOutgoing, serverIncoming] = headers['heart-beat']\n            .split(',')\n            .map((v) => parseInt(v, 10));\n        if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n            const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n            this.debug(`send PING every ${ttl}ms`);\n            this._pinger = setInterval(() => {\n                if (this._webSocket.readyState === StompSocketState.OPEN) {\n                    this._webSocket.send(BYTE.LF);\n                    this.debug('>>> PING');\n                }\n            }, ttl);\n        }\n        if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n            const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n            this.debug(`check PONG every ${ttl}ms`);\n            this._ponger = setInterval(() => {\n                const delta = Date.now() - this._lastServerActivityTS;\n                // We wait twice the TTL to be flexible on window's setInterval calls\n                if (delta > ttl * 2) {\n                    this.debug(`did not receive server activity for the last ${delta}ms`);\n                    this._closeOrDiscardWebsocket();\n                }\n            }, ttl);\n        }\n    }\n    _closeOrDiscardWebsocket() {\n        if (this.discardWebsocketOnCommFailure) {\n            this.debug(\"Discarding websocket, the underlying socket may linger for a while\");\n            this._discardWebsocket();\n        }\n        else {\n            this.debug(\"Issuing close on the websocket\");\n            this._closeWebsocket();\n        }\n    }\n    forceDisconnect() {\n        if (this._webSocket) {\n            if (this._webSocket.readyState === StompSocketState.CONNECTING ||\n                this._webSocket.readyState === StompSocketState.OPEN) {\n                this._closeOrDiscardWebsocket();\n            }\n        }\n    }\n    _closeWebsocket() {\n        this._webSocket.onmessage = () => { }; // ignore messages\n        this._webSocket.close();\n    }\n    _discardWebsocket() {\n        if (!this._webSocket.terminate) {\n            augmentWebsocket(this._webSocket, (msg) => this.debug(msg));\n        }\n        this._webSocket.terminate();\n    }\n    _transmit(params) {\n        const { command, headers, body, binaryBody, skipContentLengthHeader, } = params;\n        const frame = new FrameImpl({\n            command,\n            headers,\n            body,\n            binaryBody,\n            escapeHeaderValues: this._escapeHeaderValues,\n            skipContentLengthHeader,\n        });\n        let rawChunk = frame.serialize();\n        if (this.logRawCommunication) {\n            this.debug(`>>> ${rawChunk}`);\n        }\n        else {\n            this.debug(`>>> ${frame}`);\n        }\n        if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n            rawChunk = new TextEncoder().encode(rawChunk);\n        }\n        if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n            this._webSocket.send(rawChunk);\n        }\n        else {\n            let out = rawChunk;\n            while (out.length > 0) {\n                const chunk = out.substring(0, this.maxWebSocketChunkSize);\n                out = out.substring(this.maxWebSocketChunkSize);\n                this._webSocket.send(chunk);\n                this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n            }\n        }\n    }\n    dispose() {\n        if (this.connected) {\n            try {\n                // clone before updating\n                const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n                if (!disconnectHeaders.receipt) {\n                    disconnectHeaders.receipt = `close-${this._counter++}`;\n                }\n                this.watchForReceipt(disconnectHeaders.receipt, frame => {\n                    this._closeWebsocket();\n                    this._cleanUp();\n                    this.onDisconnect(frame);\n                });\n                this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n            }\n            catch (error) {\n                this.debug(`Ignoring error during disconnect ${error}`);\n            }\n        }\n        else {\n            if (this._webSocket.readyState === StompSocketState.CONNECTING ||\n                this._webSocket.readyState === StompSocketState.OPEN) {\n                this._closeWebsocket();\n            }\n        }\n    }\n    _cleanUp() {\n        this._connected = false;\n        if (this._pinger) {\n            clearInterval(this._pinger);\n        }\n        if (this._ponger) {\n            clearInterval(this._ponger);\n        }\n    }\n    publish(params) {\n        const { destination, headers, body, binaryBody, skipContentLengthHeader, } = params;\n        const hdrs = Object.assign({ destination }, headers);\n        this._transmit({\n            command: 'SEND',\n            headers: hdrs,\n            body,\n            binaryBody,\n            skipContentLengthHeader,\n        });\n    }\n    watchForReceipt(receiptId, callback) {\n        this._receiptWatchers[receiptId] = callback;\n    }\n    subscribe(destination, callback, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (!headers.id) {\n            headers.id = `sub-${this._counter++}`;\n        }\n        headers.destination = destination;\n        this._subscriptions[headers.id] = callback;\n        this._transmit({ command: 'SUBSCRIBE', headers });\n        const client = this;\n        return {\n            id: headers.id,\n            unsubscribe(hdrs) {\n                return client.unsubscribe(headers.id, hdrs);\n            },\n        };\n    }\n    unsubscribe(id, headers = {}) {\n        headers = Object.assign({}, headers);\n        delete this._subscriptions[id];\n        headers.id = id;\n        this._transmit({ command: 'UNSUBSCRIBE', headers });\n    }\n    begin(transactionId) {\n        const txId = transactionId || `tx-${this._counter++}`;\n        this._transmit({\n            command: 'BEGIN',\n            headers: {\n                transaction: txId,\n            },\n        });\n        const client = this;\n        return {\n            id: txId,\n            commit() {\n                client.commit(txId);\n            },\n            abort() {\n                client.abort(txId);\n            },\n        };\n    }\n    commit(transactionId) {\n        this._transmit({\n            command: 'COMMIT',\n            headers: {\n                transaction: transactionId,\n            },\n        });\n    }\n    abort(transactionId) {\n        this._transmit({\n            command: 'ABORT',\n            headers: {\n                transaction: transactionId,\n            },\n        });\n    }\n    ack(messageId, subscriptionId, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (this._connectedVersion === Versions.V1_2) {\n            headers.id = messageId;\n        }\n        else {\n            headers['message-id'] = messageId;\n        }\n        headers.subscription = subscriptionId;\n        this._transmit({ command: 'ACK', headers });\n    }\n    nack(messageId, subscriptionId, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (this._connectedVersion === Versions.V1_2) {\n            headers.id = messageId;\n        }\n        else {\n            headers['message-id'] = messageId;\n        }\n        headers.subscription = subscriptionId;\n        return this._transmit({ command: 'NACK', headers });\n    }\n}\n//# sourceMappingURL=stomp-handler.js.map"]},"metadata":{},"sourceType":"module"}