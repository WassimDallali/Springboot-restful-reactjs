{"ast":null,"code":"import { useState, useEffect, useLayoutEffect } from 'react';\nexport function useReactiveVar(rv) {\n  var value = rv();\n\n  var _a = useState(value),\n      setValue = _a[1];\n\n  useLayoutEffect(function () {\n    return rv.onNextChange(setValue);\n  }, [value]);\n  useEffect(function () {\n    return setValue(rv());\n  }, []);\n  return value;\n}","map":{"version":3,"sources":["../../../src/react/hooks/useReactiveVar.ts"],"names":[],"mappings":"AAAA,SAAS,QAAT,EAAmB,SAAnB,EAA8B,eAA9B,QAAqD,OAArD;AAGA,OAAM,SAAU,cAAV,CAA4B,EAA5B,EAA8C;AAClD,MAAM,KAAK,GAAG,EAAE,EAAhB;;AAGM,MAAA,EAAA,GAAe,QAAQ,CAAC,KAAD,CAAvB;AAAA,MAAG,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAX;;AAIN,EAAA,eAAe,CAAC,YAAA;AAAM,WAAA,EAAE,CAAC,YAAH,CAAA,QAAA,CAAA;AAAyB,GAAhC,EAAkC,CAAC,KAAD,CAAlC,CAAf;AAeA,EAAA,SAAS,CAAC,YAAA;AAAM,WAAA,QAAQ,CAAC,EAAT,EAAQ,CAAR;AAAc,GAArB,EAAuB,EAAvB,CAAT;AAEA,SAAO,KAAP;AACD","sourcesContent":["import { useState, useEffect, useLayoutEffect } from 'react';\nimport { ReactiveVar } from '../../core';\n\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  const value = rv();\n  // We don't actually care what useState thinks the value of the variable\n  // is, so we take only the update function from the returned array.\n  const [, setValue] = useState(value);\n  // We subscribe to variable updates on initial mount and when the value has\n  // changed. This avoids a subtle bug in React.StrictMode where multiple listeners\n  // are added, leading to inconsistent updates.\n  useLayoutEffect(() => rv.onNextChange(setValue), [value]);\n  // Once the component is unmounted, ignore future updates. Note that the\n  // above useEffect function returns a mute function without calling it,\n  // allowing it to be called when the component unmounts. This is\n  // equivalent to the following, but shorter:\n  // useEffect(() => {\n  //   const mute = rv.onNextChange(setValue);\n  //   return () => mute();\n  // }, [value])\n\n  // We check the variable's value in this useEffect and schedule an update if\n  // the value has changed. This check occurs once, on the initial render, to avoid\n  // a useEffect higher in the component tree changing a variable's value\n  // before the above useEffect can set the onNextChange handler. Note that React\n  // will not schedule an update if setState is called with the same value as before.\n  useEffect(() => setValue(rv()), []);\n\n  return value;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}