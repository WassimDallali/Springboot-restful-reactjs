{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"../language/blockString.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../language/predicates.mjs\";\nimport { assertValidSDLExtension } from \"../validation/validate.mjs\";\nimport { getDirectiveValues } from \"../execution/values.mjs\";\nimport { assertSchema, GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedScalarTypes, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { introspectionTypes, isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid; // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: objectValues(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      // $FlowFixMe[incompatible-call]\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n\n      var node = nodes[_i10]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n\n      var node = nodes[_i14]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18]; // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n\n      var node = nodes[_i20]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22]; // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n\n      var node = nodes[_i24]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n\n      var node = nodes[_i28]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30]; // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n\n        interfaces.push(getNamedType(type));\n      }\n    }\n\n    return interfaces;\n  }\n\n  function buildUnionTypes(nodes) {\n    var types = [];\n\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n\n      var node = nodes[_i32]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34]; // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n\n        types.push(getNamedType(type));\n      }\n    }\n\n    return types;\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n\n          return new GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n\n          return new GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n\n          return new GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n\n          return new GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || invariant(0, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}","map":{"version":3,"sources":["C:/Users/HP/Desktop/project/ecommerce-spring-reactjs-master/frontend/node_modules/graphql/utilities/extendSchema.mjs"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","objectValues","keyMap","inspect","mapValue","invariant","devAssert","Kind","TokenKind","dedentBlockStringValue","isTypeDefinitionNode","isTypeExtensionNode","assertValidSDLExtension","getDirectiveValues","assertSchema","GraphQLSchema","specifiedScalarTypes","isSpecifiedScalarType","introspectionTypes","isIntrospectionType","GraphQLDirective","GraphQLDeprecatedDirective","GraphQLSpecifiedByDirective","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","valueFromAST","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaConfig","toConfig","extendedConfig","extendSchemaImpl","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","typeDefs","typeExtensionsMap","create","directiveDefs","schemaDef","schemaExtensions","_i2","_documentAST$definiti2","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","extendedTypeName","name","existingTypeExtensions","concat","DIRECTIVE_DEFINITION","typeMap","_i4","_schemaConfig$types2","types","existingType","extendNamedType","_i6","_stdTypeMap$name","typeNode","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","directives","map","replaceDirective","buildDirective","extensions","undefined","astNode","extensionASTNodes","replaceType","type","ofType","directive","config","args","extendArg","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","_typeExtensionsMap$co","fields","field","buildInputFieldMap","_typeExtensionsMap$ty","values","buildEnumValueMap","_typeExtensionsMap$co2","specifiedByUrl","_i8","_getSpecifiedByUrl","extensionNode","getSpecifiedByUrl","_typeExtensionsMap$co3","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","_typeExtensionsMap$co4","_typeExtensionsMap$co5","getTypes","buildUnionTypes","arg","nodes","opTypes","_i10","_node$operationTypes","node","operationTypesNodes","_i12","operationType","operation","getNamedType","_stdTypeMap$name2","Error","getWrappedType","LIST_TYPE","NON_NULL_TYPE","locations","_ref","getDescription","isRepeatable","repeatable","buildArgumentMap","fieldConfigMap","_i14","_node$fields","nodeFields","_i16","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_i18","defaultValue","inputFieldMap","_i20","_node$fields2","fieldsNodes","_i22","enumValueMap","_i24","_node$values","valuesNodes","_i26","_i28","_node$interfaces","interfacesNodes","_i30","_i32","_node$types","typeNodes","_i34","_typeExtensionsMap$na","extensionNodes","OBJECT_TYPE_DEFINITION","allNodes","INTERFACE_TYPE_DEFINITION","_extensionASTNodes","_allNodes","ENUM_TYPE_DEFINITION","_extensionASTNodes2","_allNodes2","UNION_TYPE_DEFINITION","_extensionASTNodes3","_allNodes3","SCALAR_TYPE_DEFINITION","_extensionASTNodes4","INPUT_OBJECT_TYPE_DEFINITION","_extensionASTNodes5","_allNodes4","deprecated","reason","specifiedBy","url","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","next","line","String","reverse","join"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"../language/blockString.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../language/predicates.mjs\";\nimport { assertValidSDLExtension } from \"../validation/validate.mjs\";\nimport { getDirectiveValues } from \"../execution/values.mjs\";\nimport { assertSchema, GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedScalarTypes, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { introspectionTypes, isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: objectValues(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      // $FlowFixMe[incompatible-call]\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n\n      var node = nodes[_i10];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n\n      var node = nodes[_i14];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18];\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n\n      var node = nodes[_i20];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22];\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n\n      var node = nodes[_i24];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n\n      var node = nodes[_i28];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        interfaces.push(getNamedType(type));\n      }\n    }\n\n    return interfaces;\n  }\n\n  function buildUnionTypes(nodes) {\n    var types = [];\n\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n\n      var node = nodes[_i32];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        types.push(getNamedType(type));\n      }\n    }\n\n    return types;\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n\n          return new GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n\n          return new GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n\n          return new GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n\n          return new GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || invariant(0, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}